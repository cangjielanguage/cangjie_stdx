/*
 * Copyright (c) Huawei Technologies Co., Ltd. 2025. All rights reserved.
 * This source file is part of the Cangjie project, licensed under Apache-2.0
 * with Runtime Library Exception.
 *
 * See https://cangjie-lang.cn/pages/LICENSE for license information.
 */

/**
 * @file
 *
 * This file defines the @Receiver macro.
 *
 */

macro package stdx.actors.macros

import std.ast.*
import std.collection.*

/**
 * This macro can be only defined at function declaration inside @Actor.
 *
 * @since
 *
 * @throws MacroException if input is not a FuncDecl, or if the FuncDecl
 * 1. has a STATIC modifier; or
 * 2. has a OVERRIDE modifier; or
 * 3. has a OPEN modifier; or
 * 4. does not have an explicit return type.
 *
 */
public macro Receiver(attrs: Tokens, input: Tokens): Tokens {
    ReceiverMacro.run(attrs, input)
}

public macro Receiver(input: Tokens): Tokens {
    ReceiverMacro.run(Tokens(), input)
}

class ReceiverMacro {
    private let opts: MacroOptionSet
    private let errors: MacroErrors
    /*
        Because annotations are interpreted as MacroExpandDecl,
        the input tokens could be parsed into the following structure:
        head-MacroExpandDecl --> ... -> actual FuncDecl
        for example:
            @Receiver
            @Annotation1 // this is the head
            @Annotation2
            func foo()
    */
    private let headDecl: Decl
    private var fd: FuncDecl = unsafe { zeroValue<FuncDecl>() }

    static func run(attrs: Tokens, input: Tokens): Tokens {
        let errors = MacroErrors()

        // first check if @Receiver is inside @Actor
        if (!insideParentContext(ACTOR_MACRO_NAME)) {
            errors.add(MacroError.ReceiverMacroInsideActor)
            return errors.doThrow()
        }

        // parse the options
        let opts = MacroOptionParser.run(attrs, errors)
        errors.report()

        let rMacro = ReceiverMacro(input, opts, errors)

        // check the options
        rMacro.checkOptions()

        // check if it is a func decl
        rMacro.checkDecl()

        // check if receiver is valid
        rMacro.checkReceiver()

        // return modified recceiver
        rMacro.modifyReceiver(attrs)
    }

    private init(input: Tokens, opts: MacroOptionSet, errors: MacroErrors) {
        this.opts = opts
        this.errors = errors
        this.headDecl = parseDecl(input)
    }

    private func checkDecl(): Unit {
        var decl = headDecl
        while (true) {
            if (let Some(fd) <- (decl as FuncDecl)) {
                this.fd = fd
                return
            } else if (let Some(mc) <- (decl as MacroExpandDecl)) {
                decl = mc.macroInputDecl
            } else {
                errors.add(MacroError.ReceiverMacroInvalidDecl)
                return errors.doThrow()
            }
        }
    }

    private func checkOptions(): Unit {
        opts.iterate { key, _ =>
            if (key != Priority) {
                errors.add(MacroError.ReceiverMacroInvalidOption(key))
            }
            true
        }
        errors.report()
    }

    private func checkReceiver(): Unit {
        for (mod in fd.modifiers) {
            if (mod.keyword.kind == STATIC || mod.keyword.kind == OPEN || mod.keyword.kind == OVERRIDE) {
                errors.add(MacroError.ReceiverMacroInvalidModifier(fd.identifier.value))
            }
        }
        try {
            fd.declType
        } catch (_: ASTException) {
            errors.add(MacroError.ReceiverMacroInvalidReturnType(fd.identifier.value))
        }
        errors.report()
    }

    private func modifyReceiver(attrs: Tokens): Tokens {
        /*
            @Receiver[expr]
            func foo(arg1: Ty1, ..., argN: TyN): RetTy { body }
            =>
            @prefixReceiver[expr]
            func foo(arg1: Ty1, ..., argN: TyN): RetTy { body }
        */
        let options = if (attrs.size == 0) { Tokens() } else { quote([$attrs]) }
        quote(
            @$receiverMarkerToken$options
            $headDecl
        )
    }
}